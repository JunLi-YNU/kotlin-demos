# 协程的构建方式
## GlobalScope
> 一个App级别的协程，如果任务没有完成在App被关闭前都不会被关闭。
## runBlocking
> 把主线程变成一个协程,它会阻塞主线程main等待协程执行完毕。
### 协程的构建器

> **launch 和 async构建器都可以用来启动一个协程**
> launch:返回一个job不附带任何结果值。
> async:返回一个Deferred，Deferred也是一个job，可以使用.await()在一个延期的值上得到它的结果。

#### 结构化并发
> 多个协程共同执行
```kotlin
    fun combineAsync() = runBlocking {
        val executedTime = measureTimeMillis {
            val first = async { doCoroutine() }
            val second = async { doCoroutine() }
            println("The result: ${first.await() + second.await()}")
        }
        println("Completed in $executedTime ms.")
    }
    fun wrongUseCombineAsync() = runBlocking {
        val executedTime = measureTimeMillis {
            //错误的使用方法，这时的协程是同步的
            val first = async{ doCoroutine()}.await()
            val second = async{ doCoroutine()}.await()
            println("The result: ${first + second}")
        }
        println("Completed in $executedTime ms.")
    }

    private suspend fun doCoroutine(): Int {
        delay(1000)
        return 10
    }
```
### 协程的启动模式
>1.CoroutineStart.DEFAULT : 构建协程后立即开始调度，在调度前如果被取消，则立即进入取消响应状态。
>2.CoroutineStart.ATOMIC : 构建协程后立即开始调度，执行到第一个挂起点之前不响应取消。
>3.CoroutineStart.LAZY : 只有在协程被主动调用时才开始调度，在调度前如果被取消，则立即进入异常响应状态。
>4.CoroutineStart.UNDISPATCHED :协程构建后立即在当前线程立即执行。

### 协程的作用域
>**coroutineScope:**作用域当一个协程失败时，该作用域中所有协程都被取消。
>**supervisorScope:**作用域一个协程失败时，不会影响该作用域的其他协程的执行。

### Job的生命周期
>1.每通过launch或者async创建一个协程，都会返回一个Job实例，该实例是协程的唯一标识，并且负责管理协程的生命周期。
>2.一个Job包含一系列的状态：New新创建，Active活跃，Completing完成中，Completed已完成，Canceling取消中，Cancelled已取消。
>3.Job的状态是无法直接访问的，但是可以访问Job的属性：isActive，isCancelled，isCompleted.
### 协程的取消
#### 协程的作用域的取消
```kotlin
    fun scopeCancel() = runBlocking {
        //CoroutineScope作用域是独立的，并没有继承runBlocking
        val scope = CoroutineScope(Dispatchers.Default)
        scope.launch {
            delay(1000)
            println("JobFirst finished.")
        }
        scope.launch {
            delay(1000)
            println("JonSecond finished.")
        }
        delay(500)
        //协程没有执行完成前，取消作用域就能取消协程
        scope.cancel()
        //由于runBlocking的作用域与CoroutineScope不同，所以runBlocking不会等待CoroutineScope中的协程执行完成
        delay(2000)
    }
```
#### 协程CPU密集型任务的取消
>1.isActive是一个可以被使用在CoroutinesScope中的扩展属性，检查Job是否处于活跃状态。
>2.ensureActive(),如果Job处于非活跃状态，这个方法会立即抛出异常。
>3.yield()函数会检查所在协程的状态，如果已经取消，则会抛出CancellationException予以响应，此外它还会让出执行权，给其他协程提供执行机会。


